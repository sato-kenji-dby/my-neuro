# Live2D 交互问题故障排查日志

本文档记录了针对 Live2D 模型交互问题的诊断和修复尝试。

## 1. 初始问题描述

在应用初始版本中，存在两个主要的交互问题：

1.  **交互范围过大**：Live2D 模型的实际可交互区域（点击、悬停）比模型本身的可视范围要大，向左右各延伸了约一个身位的距离。
2.  **初始交互失效**：应用启动时，无法立即与 Live2D 模型进行交互。鼠标指针会直接“穿透”模型。必须先与其他 UI 元素（如下方的聊天框或待办事项板）进行交互，才能“唤醒”模型的交互功能。

## 2. 解决方案探索与尝试

### 2.1 修复交互范围问题

#### 分析

通过检查 `live-2d/src/js/renderer/model-interaction.ts`，发现代码中虽然有一个 `updateInteractionArea` 函数，但其计算结果并未被应用到模型的 `hitArea`（点击区域）属性上。当 `hitArea` 未定义时，PIXI.js 默认使用模型的几何边界框（bounding box）作为交互区域，这个边界框通常大于模型的实际渲染区域，导致了交互范围过大的问题。

#### 第一次尝试（失败）

-   **操作**：修改 `model-interaction.ts`，尝试将模型内部定义的点击区域集合直接赋值给 `hitArea` 属性：`this.model.hitArea = this.model.internalModel.hitAreas;`。
-   **结果**：失败。此操作导致了 TypeScript 编译错误，因为 `hitArea` 期望一个实现了 `contains` 方法的单一对象，而 `internalModel.hitAreas` 是一个多区域的记录集合，类型不匹配。

#### 第二次尝试（成功）

-   **操作**：再次修改 `model-interaction.ts`，移除了上述错误的 `hitArea` 赋值代码。
-   **分析与结论**：深入研究 `pixi-live2d-display` 库的行为后发现，当 `model.interactive = true;` 被设置时，库的默认 `containsPoint` 方法会自动使用 `internalModel.hitAreas` 进行精确的命中测试。因此，之前添加的代码是多余的。只需确保 `model.interactive` 为 `true` 即可。**此操作最终成功解决了交互范围过大的问题。**

---

### 2.2 修复初始交互失效问题

#### 分析

此问题的根源在于 Electron 的主进程在创建窗口时，默认设置了 `setIgnoreMouseEvents(true, { forward: true })`，导致整个窗口启动时就是鼠标穿透的。渲染进程需要通过 IPC 向主进程发送 `request-set-ignore-mouse-events` 消息来动态改变这个状态。问题在于，启动时没有任何事件触发第一个 `{ ignore: false }` 消息，导致了“先有鸡还是先有蛋”的死锁：需要鼠标事件来关闭穿透，但穿透状态本身阻止了鼠标事件的发生。

#### 第一次尝试 - 方案 A (失败)

-   **操作**：修改 `live-2d/src/ui/pages/+page.svelte`。在模型加载完成后，立即发送 `setIgnoreMouse(false)` 来禁用穿透，然后用 `setTimeout` 检查当前鼠标指针是否在模型上，如果不在，则重新发送 `setIgnoreMouse(true)` 启用穿透。
-   **结果**：失败。用户反馈问题依旧存在，表明这种时机触发的检查未能稳定地解决问题。

#### 第二次尝试 - 方案 B (失败)

-   **操作**：鉴于方案 A 失败，采用一个更直接的“快速方案”。修改 `+page.svelte`，在模型加载后，强制禁用穿透 2 秒 (`setIgnoreMouse(false)`)，然后无条件地重新启用穿透 (`setIgnoreMouse(true)`)，旨在提供一个明确的“可交互窗口期”。
-   **结果**：失败。用户反馈，在 2 秒窗口期结束后，如果鼠标没有恰好在模型上，模型依然会被穿透，问题重现。必须移动鼠标到其他 UI 元素上才能恢复正常。

## 3. 当前状态与结论

-   **交互范围问题**：已解决。
-   **初始交互失效问题**：**未解决**。

尽管尝试了多种方案，但启动时的交互死锁问题依然存在。根本原因可能在于 Electron、Svelte 和 PIXI.js 之间复杂的事件循环和渲染时序。

**最终结论**：此问题被归类为**已知问题**。由于用户可以通过将鼠标移至其他UI元素上轻松绕开此问题，因此暂时搁置，不再投入更多时间进行修复，以优先处理其他更高价值的任务。
